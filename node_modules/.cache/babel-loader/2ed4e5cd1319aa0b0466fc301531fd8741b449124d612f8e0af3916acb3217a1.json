{"ast":null,"code":"import Papa from 'papaparse';\nimport * as XLSX from 'xlsx';\n\n/**\n * Process a file (CSV or Excel) and return the structured data\n * @param {File} file - The file object to process\n * @returns {Promise<Array>} - The structured data from the file\n */\nexport const processFile = async file => {\n  if (!file) {\n    throw new Error('No file provided');\n  }\n  try {\n    if (file.name.endsWith('.csv')) {\n      return await processCSV(file);\n    } else if (file.name.match(/\\.xlsx?$/)) {\n      return await processExcel(file);\n    } else {\n      throw new Error('Unsupported file type. Please upload a CSV or Excel file.');\n    }\n  } catch (error) {\n    console.error('Error processing file:', error);\n    throw error;\n  }\n};\n\n/**\n * Process a CSV file and return the data\n * @param {File} file - The CSV file\n * @returns {Promise<Array>} - Parsed CSV data\n */\nconst processCSV = async file => {\n  const text = await file.text();\n  return new Promise((resolve, reject) => {\n    Papa.parse(text, {\n      header: true,\n      skipEmptyLines: true,\n      transformHeader: header => header.trim(),\n      complete: results => {\n        // Validate required columns (example)\n        if (!validateCitationData(results.data)) {\n          reject(new Error('CSV file is missing required columns (title and/or abstract)'));\n          return;\n        }\n\n        // Add IDs if not present\n        const data = results.data.map((row, index) => ({\n          id: row.id || `citation-${index}`,\n          ...row\n        }));\n        resolve(data);\n      },\n      error: error => {\n        reject(new Error(`CSV parsing error: ${error.message}`));\n      }\n    });\n  });\n};\n\n/**\n * Process an Excel file and return the data\n * @param {File} file - The Excel file\n * @returns {Promise<Array>} - Parsed Excel data\n */\nconst processExcel = async file => {\n  const buffer = await file.arrayBuffer();\n  const workbook = XLSX.read(buffer, {\n    type: 'array'\n  });\n\n  // Get the first worksheet\n  const firstSheet = workbook.Sheets[workbook.SheetNames[0]];\n  const data = XLSX.utils.sheet_to_json(firstSheet);\n\n  // Validate required columns (example)\n  if (!validateCitationData(data)) {\n    throw new Error('Excel file is missing required columns (title and/or abstract)');\n  }\n\n  // Add IDs if not present\n  return data.map((row, index) => ({\n    id: row.id || `citation-${index}`,\n    ...row\n  }));\n};\n\n/**\n * Validate that the citation data has the required columns\n * @param {Array} data - The data to validate\n * @returns {boolean} - Whether the data is valid\n */\nconst validateCitationData = data => {\n  if (!data || data.length === 0) {\n    return false;\n  }\n\n  // Check for required columns in the first row\n  const firstRow = data[0];\n  const hasTitle = 'title' in firstRow || 'Title' in firstRow;\n  const hasAbstract = 'abstract' in firstRow || 'Abstract' in firstRow;\n  return hasTitle && hasAbstract;\n};\n\n/**\n * Convert data to CSV and trigger a download\n * @param {Array} data - The data to convert to CSV\n * @param {string} filename - The name of the file to download\n */\nexport const downloadCSV = (data, filename = 'download.csv') => {\n  if (!data || data.length === 0) {\n    console.error('No data to download');\n    return;\n  }\n  const csv = Papa.unparse(data);\n  const blob = new Blob([csv], {\n    type: 'text/csv;charset=utf-8;'\n  });\n  const url = URL.createObjectURL(blob);\n  const link = document.createElement('a');\n  link.href = url;\n  link.setAttribute('download', filename);\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n};\n\n/**\n * Convert data to Excel and trigger a download\n * @param {Array} data - The data to convert to Excel\n * @param {string} filename - The name of the file to download\n */\nexport const downloadExcel = (data, filename = 'download.xlsx') => {\n  if (!data || data.length === 0) {\n    console.error('No data to download');\n    return;\n  }\n  const worksheet = XLSX.utils.json_to_sheet(data);\n  const workbook = XLSX.utils.book_new();\n  XLSX.utils.book_append_sheet(workbook, worksheet, 'Results');\n  XLSX.writeFile(workbook, filename);\n};","map":{"version":3,"names":["Papa","XLSX","processFile","file","Error","name","endsWith","processCSV","match","processExcel","error","console","text","Promise","resolve","reject","parse","header","skipEmptyLines","transformHeader","trim","complete","results","validateCitationData","data","map","row","index","id","message","buffer","arrayBuffer","workbook","read","type","firstSheet","Sheets","SheetNames","utils","sheet_to_json","length","firstRow","hasTitle","hasAbstract","downloadCSV","filename","csv","unparse","blob","Blob","url","URL","createObjectURL","link","document","createElement","href","setAttribute","body","appendChild","click","removeChild","downloadExcel","worksheet","json_to_sheet","book_new","book_append_sheet","writeFile"],"sources":["/Users/sheme/Desktop/literature-review-tool/src/utils/fileHandlers.js"],"sourcesContent":["import Papa from 'papaparse';\nimport * as XLSX from 'xlsx';\n\n/**\n * Process a file (CSV or Excel) and return the structured data\n * @param {File} file - The file object to process\n * @returns {Promise<Array>} - The structured data from the file\n */\nexport const processFile = async (file) => {\n  if (!file) {\n    throw new Error('No file provided');\n  }\n\n  try {\n    if (file.name.endsWith('.csv')) {\n      return await processCSV(file);\n    } else if (file.name.match(/\\.xlsx?$/)) {\n      return await processExcel(file);\n    } else {\n      throw new Error('Unsupported file type. Please upload a CSV or Excel file.');\n    }\n  } catch (error) {\n    console.error('Error processing file:', error);\n    throw error;\n  }\n};\n\n/**\n * Process a CSV file and return the data\n * @param {File} file - The CSV file\n * @returns {Promise<Array>} - Parsed CSV data\n */\nconst processCSV = async (file) => {\n  const text = await file.text();\n  \n  return new Promise((resolve, reject) => {\n    Papa.parse(text, {\n      header: true,\n      skipEmptyLines: true,\n      transformHeader: header => header.trim(),\n      complete: (results) => {\n        // Validate required columns (example)\n        if (!validateCitationData(results.data)) {\n          reject(new Error('CSV file is missing required columns (title and/or abstract)'));\n          return;\n        }\n        \n        // Add IDs if not present\n        const data = results.data.map((row, index) => ({\n          id: row.id || `citation-${index}`,\n          ...row\n        }));\n        \n        resolve(data);\n      },\n      error: (error) => {\n        reject(new Error(`CSV parsing error: ${error.message}`));\n      }\n    });\n  });\n};\n\n/**\n * Process an Excel file and return the data\n * @param {File} file - The Excel file\n * @returns {Promise<Array>} - Parsed Excel data\n */\nconst processExcel = async (file) => {\n  const buffer = await file.arrayBuffer();\n  const workbook = XLSX.read(buffer, { type: 'array' });\n  \n  // Get the first worksheet\n  const firstSheet = workbook.Sheets[workbook.SheetNames[0]];\n  const data = XLSX.utils.sheet_to_json(firstSheet);\n  \n  // Validate required columns (example)\n  if (!validateCitationData(data)) {\n    throw new Error('Excel file is missing required columns (title and/or abstract)');\n  }\n  \n  // Add IDs if not present\n  return data.map((row, index) => ({\n    id: row.id || `citation-${index}`,\n    ...row\n  }));\n};\n\n/**\n * Validate that the citation data has the required columns\n * @param {Array} data - The data to validate\n * @returns {boolean} - Whether the data is valid\n */\nconst validateCitationData = (data) => {\n  if (!data || data.length === 0) {\n    return false;\n  }\n  \n  // Check for required columns in the first row\n  const firstRow = data[0];\n  const hasTitle = 'title' in firstRow || 'Title' in firstRow;\n  const hasAbstract = 'abstract' in firstRow || 'Abstract' in firstRow;\n  \n  return hasTitle && hasAbstract;\n};\n\n/**\n * Convert data to CSV and trigger a download\n * @param {Array} data - The data to convert to CSV\n * @param {string} filename - The name of the file to download\n */\nexport const downloadCSV = (data, filename = 'download.csv') => {\n  if (!data || data.length === 0) {\n    console.error('No data to download');\n    return;\n  }\n  \n  const csv = Papa.unparse(data);\n  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });\n  const url = URL.createObjectURL(blob);\n  \n  const link = document.createElement('a');\n  link.href = url;\n  link.setAttribute('download', filename);\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n};\n\n/**\n * Convert data to Excel and trigger a download\n * @param {Array} data - The data to convert to Excel\n * @param {string} filename - The name of the file to download\n */\nexport const downloadExcel = (data, filename = 'download.xlsx') => {\n  if (!data || data.length === 0) {\n    console.error('No data to download');\n    return;\n  }\n  \n  const worksheet = XLSX.utils.json_to_sheet(data);\n  const workbook = XLSX.utils.book_new();\n  XLSX.utils.book_append_sheet(workbook, worksheet, 'Results');\n  \n  XLSX.writeFile(workbook, filename);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}